# Lab14  —  Игра Жизнь

Tags: share
Created time: January 18, 2024 4:01 PM
Last edited time: January 18, 2024 5:27 PM
Status: In progress
ID: 17

[Лабораторная 14](https://www.notion.so/14-31df9f46fbe6466783493a8c69ffddc3?pvs=21)

# Об игре жизнь

Игра "Жизнь" (англ. "Game of Life") - это клеточный автомат, разработанный британским математиком Джоном Конвеем в 1970 году. Она является примером "нульмерной игры", то есть игры без игроков, где состояние каждой клетки зависит только от состояния ее соседей.

Правила игры "Жизнь" следующие:

1. Любая живая клетка с меньше чем двумя живыми соседями умирает от "одиночества".
2. Любая живая клетка с двумя или тремя живыми соседями остается живой и переходит в следующее поколение.
3. Любая живая клетка с более чем тремя живыми соседями умирает от "перенаселенности".
4. Любая мертвая клетка с ровно тремя живыми соседями становится живой.

В игре "Жизнь" каждое поколение определяется состоянием предыдущего поколения. Каждая клетка может быть либо живой, либо мертвой. Состояние всех клеток обновляется одновременно на каждом шаге, и таким образом, эволюция игры происходит поколение за поколением.

Игра "Жизнь" является примером простой и универсальной модели, которая может имитировать различные формы поведения и эволюции. Она применяется в различных областях, таких как биология, компьютерная графика, искусственный интеллект и другие.

В предоставленном коде программы представлены определения и разбор кода для реализации игры "Жизнь" на языке программирования C. Он включает в себя определение структур `BMPHeader` и `GameConfig`, функцию `parseCommandLineArgs` для обработки аргументов командной строки, а также основной код программы в функции `main`. В коде используются различные функции и конструкции языка C, такие как `strcmp`, `fopen`, `perror`, `mkdir`, `strtol` и другие, для чтения аргументов командной строки, открытия файлов, обработки ошибок и установки параметров игры.

# Написание кода

## main definitions

```c
int main(int argc, char *argv[]) {}
```

`int argc, char *argv[]` в функции `main` используются для передачи аргументов командной строки в программу. `argc` представляет собой количество аргументов командной строки, а `argv` представляет собой массив строк, каждая из которых содержит один из аргументов командной строки. Это позволяет программе получать входные данные или настройки из командной строки при запуске.

```c
int main(int argc, char *argv[]) {
		BMPHeader bmpHeader;
    GameConfig config = {1, 1, NULL};
    FILE *inputFile = NULL;
```

### BMPHeader

```c
typedef struct {
    unsigned char header[54];
    int width;
    int height;
    int size;
} BMPHeader;
```

`typedef` в языке C используется для создания псевдонима (алиаса) для типа данных. Он позволяет определить новое имя для существующего типа данных, что делает код более читаемым и понятным.
В данном случае, `typedef` используется для создания структуры `BMPHeader`, которая содержит информацию о заголовке BMP-файла, такую как ширина, высота и размер файла. Псевдоним `BMPHeader` позволяет удобнее обращаться к этой структуре в коде программы.

### GameConfig

```c
typedef struct {
    int maxIter;
    int dumpFreq;
    char *output;
} GameConfig;
```

В структуре `GameConfig` поле `char *output` является указателем на массив символов, который хранит путь к папке для сохранения файлов.

При использовании `strcpy` и `strcat`, когда вы создаете полный путь к файлу, вы должны убедиться, что выделена достаточная память для хранения всей строки, включая символы пути и разделители директорий. Память для строки обычно выделяется динамически с помощью функций, таких как `malloc` или `calloc`.

После использования строки `output` в структуре `GameConfig`, вы должны освободить память, чтобы избежать утечки памяти. Это делается с помощью функции `free`, передавая ей указатель на выделенную память.

Обратите внимание, что в предоставленном коде память для `output` не выделяется, поэтому перед использованием этой переменной вам необходимо выделить память с помощью `malloc` или подобной функции, а затем освободить память с помощью `free` после того, как она больше не нужна.

## parseCommandLineArgs

```c
int main(int argc, char *argv[]) {
    BMPHeader bmpHeader;
    GameConfig config = {1, 1, NULL};
    FILE *inputFile = NULL;

    parseCommandLineArgs(argc, argv, &config, &inputFile);
```

```c
void parseCommandLineArgs(int argc, char *argv[], GameConfig *config, FILE **inputFile) {
    for (int i = 1; i < argc; ++i) {
        if (!strcmp("--input", argv[i]) && i + 1 < argc) {
            *inputFile = fopen(argv[i + 1], "rb");
            if (!*inputFile)
                perror("Error opening input file");
        } else if (!strcmp("--output", argv[i]) && i + 1 < argc) {
            config->output = argv[i + 1];
            mkdir(config->output);
        } else if (!strcmp("--max_iter", argv[i]) && i + 1 < argc) {
            config->maxIter = strtol(argv[i + 1], NULL, 10);
        } else if (!strcmp("--dump_freq", argv[i]) && i + 1 < argc) {
            config->dumpFreq = strtol(argv[i + 1], NULL, 10);
        }
    }
}
```

Функция `parseCommandLineArgs` принимает входные аргументы командной строки и анализирует их для установки соответствующих значений в структуре `GameConfig` и файла ввода.

Она принимает следующие параметры:

- `argc`: количество аргументов командной строки.
- `argv`: массив строк, содержащих аргументы командной строки.
- `config`: указатель на структуру `GameConfig`, в которую будут записаны значения.
- `inputFile`: указатель на указатель на файл ввода. Функция откроет файл и присвоит его указатель данному указателю.

Внутри функции происходит цикл по всем аргументам командной строки. Для каждого аргумента проверяется его значение и соответствующим образом обрабатывается:

- Если аргумент равен `--input` и следующий аргумент существует, то функция открывает файл с указанным именем в режиме чтения (`"rb"`) и присваивает указатель на файл переменной `inputFile`.
- Если аргумент равен `--output` и следующий аргумент существует, то функция присваивает значение следующего аргумента переменной `config->output` и создает директорию с указанным именем с помощью функции `mkdir`.
- Если аргумент равен `--max_iter` и следующий аргумент существует, то функция преобразует следующий аргумент в число с помощью функции `strtol` и присваивает полученное значение переменной `config->maxIter`.
- Если аргумент равен `--dump_freq` и следующий аргумент существует, то функция преобразует следующий аргумент в число с помощью функции `strtol` и присваивает полученное значение переменной `config->dumpFreq`.

Таким образом, функция `parseCommandLineArgs` позволяет настроить параметры игры, указанные в командной строке, сохраняя их в структуре `GameConfig` и открывает файл ввода для дальнейшей обработки.

### strcmp

`strcmp` - это функция в языке программирования C, которая используется для сравнения двух строк. Она принимает два аргумента - строки, которые будут сравниваться. Возвращает она целое число, которое указывает на отношение между строками.

Возможные возвращаемые значения функции `strcmp`:

- Если строки равны, то функция возвращает 0.
- Если первая строка лексикографически меньше второй, то функция возвращает отрицательное число.
- Если первая строка лексикографически больше второй, то функция возвращает положительное число.

Функция `strcmp` сравнивает строки посимвольно, начиная с первого символа, пока не встретит различие или не достигнет конца одной из строк. Поэтому, если строки отличаются только в некотором символе, сравнение будет завершено на этом символе.

Пример использования функции `strcmp`:

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str1[] = "hello";
    char str2[] = "world";

    int result = strcmp(str1, str2);

    if (result == 0) {
        printf("The strings are equal\n");
    } else if (result < 0) {
        printf("The first string is less than the second string\n");
    } else {
        printf("The first string is greater than the second string\n");
    }

    return 0;
}

```

В данном примере функция `strcmp` сравнивает строки "hello" и "world". Поскольку первая строка лексикографически меньше второй, результат будет отрицательным числом.

Пример использования функции `strcmp`, в котором она возвращает 0:

```c
#include <stdio.h>
#include <string.h>

int main() {
    char str1[] = "hello";
    char str2[] = "hello";

    int result = strcmp(str1, str2);

    if (result == 0) {
        printf("The strings are equal\\n");
    } else if (result < 0) {
        printf("The first string is less than the second string\\n");
    } else {
        printf("The first string is greater than the second string\\n");
    }

    return 0;
}

```

В этом примере функция `strcmp` сравнивает две строки "hello". Поскольку строки идентичны, функция возвращает 0. В результате будет напечатано "The strings are equal".

### fopen

`fopen` - это функция в языке программирования C, которая используется для открытия файла. Она принимает два аргумента - имя файла и режим открытия файла. Возвращает указатель на структуру `FILE`, которая представляет открытый файл.

Синтаксис функции `fopen`:

```c
FILE *fopen(const char *filename, const char *mode);
```

Аргументы функции `fopen`:

- `filename` - имя файла, который нужно открыть.
- `mode` - режим открытия файла.

Возможные значения для `mode`:

- `"r"`: Открыть файл для чтения.
- `"w"`: Открыть файл для записи. Если файл уже существует, его содержимое будет удалено. Если файл не существует, будет создан новый файл.
- `"a"`: Открыть файл для записи. Если файл уже существует, новые данные будут добавлены в конец файла. Если файл не существует, будет создан новый файл.
- `"rb"`: Открыть бинарный файл для чтения.
- `"wb"`: Открыть бинарный файл для записи.
- `"ab"`: Открыть бинарный файл для записи, добавляя данные в конец файла.

Другие возможные значения для `mode` в функции `fopen`:

- `"r+"`: Открыть файл для чтения и записи. Файл должен существовать.
- `"w+"`: Открыть файл для чтения и записи. Если файл уже существует, его содержимое будет удалено. Если файл не существует, будет создан новый файл.
- `"a+"`: Открыть файл для чтения и записи. Если файл уже существует, новые данные будут добавлены в конец файла. Если файл не существует, будет создан новый файл.
- `"rb+"`: Открыть бинарный файл для чтения и записи. Файл должен существовать.
- `"wb+"`: Открыть бинарный файл для чтения и записи. Если файл уже существует, его содержимое будет удалено. Если файл не существует, будет создан новый файл.
- `"ab+"`: Открыть бинарный файл для чтения и записи. Если файл уже существует, новые данные будут добавлены в конец файла. Если файл не существует, будет создан новый файл.

Комбинация символов `+` в режиме открытия позволяет файлу быть открытым и для чтения, и для записи. Это означает, что можно выполнять операции чтения и записи с использованием открытого файла.

Пример использования функции `fopen`:

```c
#include <stdio.h>

int main() {
    FILE *file = fopen("example.txt", "w");

    if (file == NULL) {
        printf("Failed to open the file.\\n");
        return 1;
    }

    fprintf(file, "This is an example file.");

    fclose(file);

    return 0;
}
```

В этом примере функция `fopen` открывает файл с именем "example.txt" для записи. Если файл успешно открыт, то в него записывается строка "This is an example file." с помощью функции `fprintf`. Затем файл закрывается с помощью функции `fclose`.

Если `fopen` не может открыть файл, то она возвращает `NULL`. Поэтому перед использованием указателя на файл, нужно проверить его на `NULL`, чтобы убедиться, что файл был успешно открыт.

### Причины, по которым рекомендуется закрывать файлы:

1. Освобождение ресурсов: Когда файл открыт, операционная система выделяет определенные ресурсы для работы с этим файлом. Закрытие файла позволяет освободить эти ресурсы и предотвратить утечку памяти или других системных ресурсов.
2. Предоставление доступа другим процессам: Когда файл открыт, другим процессам может быть запрещен доступ к этому файлу. Закрытие файла позволяет другим процессам получить доступ к файлу для чтения или записи.
3. Сохранение изменений: Некоторые операционные системы или файловые системы могут кэшировать изменения, сделанные в файле, и не записывать эти изменения на диск, пока файл не будет закрыт. Закрытие файла гарантирует, что все изменения будут записаны немедленно.
4. Предотвращение повреждения данных: Если файл остается открытым, возможно случайное изменение его содержимого или удаление файла другим процессом. Закрытие файла защищает его от таких нежелательных изменений.
5. Переносимость программы: Закрытие файла делает программу более переносимой, так как разные операционные системы могут иметь различное поведение при работе с открытыми файлами. Закрытие файла гарантирует, что программа будет работать одинаково на разных платформах.

В целом, закрытие файлов после их использования является хорошей практикой программирования, которая помогает обеспечить безопасность, эффективность и надежность работы с файлами.

### perror

`perror` - это функция в языке программирования C, которая используется для вывода сообщения об ошибке в соответствии с кодом ошибки, возвращаемым другими функциями. Она выводит сообщение об ошибке, связанное с последней ошибкой, возникшей в системных вызовах или стандартных библиотечных функциях.

Синтаксис функции `perror`:

```c
void perror(const char *s);
```

Аргумент функции `perror`:

- `s` - строка, которая будет выведена перед сообщением об ошибке.

Функция `perror` использует значение глобальной переменной `errno`, которая содержит код последней ошибки, чтобы определить сообщение об ошибке, которое нужно вывести.

`perror` выводит сообщение об ошибке в поток ошибок `stderr`. Сообщение об ошибке содержит строку `s`, после которой следует символ двоеточия и пробел, а затем сообщение об ошибке, соответствующее коду ошибки из `errno`.

Пример использования функции `perror`:

```c
#include <stdio.h>
#include <errno.h>

int main() {
    FILE *file = fopen("nonexistent_file.txt", "r");

    if (file == NULL) {
        perror("Failed to open the file");
        printf("Error code: %d\n", errno);
        return 1;
    }

    fclose(file);

    return 0;
}
```

В этом примере функция `fopen` пытается открыть файл с именем "nonexistent_file.txt" для чтения. Если файл не существует, `fopen` вернет `NULL`, а затем `perror` будет вызвана с сообщением "Failed to open the file". Функция `errno` используется для получения кода ошибки. Затем программа выводит сообщение об ошибке и код ошибки с помощью функции `printf`.

Функция `perror` выводит сообщение об ошибке на стандартный поток ошибок `stderr`, который обычно выводится в консоль. Это позволяет отслеживать ошибки и выводить сообщения об ошибках для удобства отладки и обработки ошибок.

### mkdir

`mkdir` - это функция в языке программирования C, которая используется для создания директории (папки) в файловой системе. Она позволяет программе создавать новые директории для хранения файлов.

Синтаксис функции `mkdir`:

```c
int mkdir(const char *path, mode_t mode);

```

Аргументы функции `mkdir`:

- `path` - строка, содержащая путь к создаваемой директории.
- `mode` - специальные флаги и разрешения, которые будут применены к создаваемой директории.
    - Возможные значения `mode`:
        - `S_IRWXU` - разрешение для владельца (читать, писать и выполнять).
        - `S_IRUSR` - разрешение на чтение для владельца.
        - `S_IWUSR` - разрешение на запись для владельца.
        - `S_IXUSR` - разрешение на выполнение для владельца.
        - `S_IRWXG` - разрешение для группы (читать, писать и выполнять).
        - `S_IRGRP` - разрешение на чтение для группы.
        - `S_IWGRP` - разрешение на запись для группы.
        - `S_IXGRP` - разрешение на выполнение для группы.
        - `S_IRWXO` - разрешение для других пользователей (читать, писать и выполнять).
        - `S_IROTH` - разрешение на чтение для других пользователей.
        - `S_IWOTH` - разрешение на запись для других пользователей.
        - `S_IXOTH` - разрешение на выполнение для других пользователей.

Функция `mkdir` возвращает 0 при успешном создании директории. В случае ошибки, она возвращает -1 и устанавливает значение переменной `errno`, которая содержит код ошибки, указывающий на причину ошибки.

Пример использования функции `mkdir` для создания новой директории:

```c
#include <stdio.h>
#include <sys/stat.h>

int main() {
    int result = mkdir("new_directory", S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH);

    if (result == 0) {
        printf("Directory created successfully.\n");
    } else {
        perror("Failed to create directory");
        return 1;
    }

    return 0;
}
```

В этом примере функция `mkdir` создает новую директорию с именем "new_directory" и разрешениями для владельца на чтение, запись и выполнение, для группы и других пользователей на чтение и выполнение. Если директория успешно создана, программа выведет сообщение "Directory created successfully." В противном случае, будет выведено сообщение об ошибке с помощью функции `perror`.

### strtol

`strtol` - это функция в языке программирования C, которая используется для преобразования строки в число типа `long int`. Она позволяет программе считывать числовые значения из строк и использовать их для различных вычислений и операций.

Синтаксис функции `strtol`:

```c
long int strtol(const char *str, char **endptr, int base);

```

Аргументы функции `strtol`:

- `str` - строка, которую нужно преобразовать в число.
- `endptr` - указатель на указатель на символ, где будет сохранена позиция первого не преобразуемого символа в строке. Может быть установлено в `NULL`, если позиция не требуется.
- `base` - основание системы счисления, которое определяет, как интерпретировать числовые значения в строке. Значение `0` указывает на автоматическое определение основания системы счисления на основе префикса числа (`0x` для шестнадцатеричной системы счисления, `0` для восьмеричной системы счисления, `0b` для двоичной системы счисления). В противном случае, основание системы счисления должно быть указано явно (от `2` до `36`).

Возвращаемое значение функции `strtol`:

- Если преобразование прошло успешно, функция возвращает полученное числовое значение типа `long int`.
- Если строка не содержит числового значения, то возвращается значение `0`.
- Если в строке встречается неправильный символ, который не является частью числа, то возвращается значение `0` и переменная, на которую указывает `endptr`, устанавливается на позицию этого символа в строке.

Пример использования функции `strtol`:

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    char str[] = "12345";
    char *endptr;
    long int num = strtol(str, &endptr, 10);

    if (*endptr != '\\0') {
        printf("Invalid number format\\n");
        return 1;
    }

    printf("The number is: %ld\\n", num);

    return 0;
}

```

В этом примере функция `strtol` преобразует строку "12345" в число типа `long int`. Результат сохраняется в переменной `num`. Затем проверяется, содержит ли переменная `endptr` нулевой символ, что означает успешное преобразование. Если `endptr` указывает на символ, отличный от нулевого, то выводится сообщение "Invalid number format". В противном случае, число выводится на экран с помощью функции `printf`.

Функция `strtol` может быть полезна, например, при чтении числовых значений из строковых аргументов командной строки или при обработке числовых значений, полученных из файла или других источников данных.

Обратите внимание, что функция `strtol` выполняет преобразование строки только до первого не преобразуемого символа. Если строка содержит дополнительные символы после числового значения, они будут проигнорированы. Если вам нужно преобразовать всю строку, включая дополнительные символы, можно использовать функции `sscanf` или `atoi`.

## getBMPHeaderData

```c
int main(int argc, char *argv[]) {
    BMPHeader bmpHeader;
    GameConfig config = {1, 1, NULL};
    FILE *inputFile = NULL;

    parseCommandLineArgs(argc, argv, &config, &inputFile);

    getBMPHeaderData(inputFile, &bmpHeader);
```

```c
void getBMPHeaderData(FILE *file, BMPHeader *bmp) {
    fread(bmp->header, 1, 54, file);
    bmp->width = bmp->header[21] * 16777216 + bmp->header[20] * 65536 + bmp->header[19] * 256 + bmp->header[18];
    bmp->height = bmp->header[25] * 16777216 + bmp->header[24] * 65536 + bmp->header[23] * 256 + bmp->header[22];
    bmp->size = bmp->header[5] * 16777216 + bmp->header[4] * 65536 + bmp->header[3] * 256 + bmp->header[2];
}
```

Функция `getBMPHeaderData` используется для получения данных заголовка BMP-файла из файла и сохранения их в структуре `BMPHeader`.

Она принимает следующие параметры:

- `file`: указатель на файл, из которого нужно прочитать данные.
- `bmp`: указатель на структуру `BMPHeader`, в которую будут записаны данные заголовка.

Внутри функции происходит чтение 54 байтов из файла с помощью функции `fread`. Эти 54 байта содержат информацию о заголовке BMP-файла. Затем данные заголовка распаковываются и сохраняются в соответствующих полях структуры `BMPHeader`.

- `bmp->header`: это массив байтов (размером 54 байта), в котором сохраняется весь заголовок BMP-файла.
- `bmp->width`: это поле, в которое записывается ширина изображения, полученная из заголовка.
- `bmp->height`: это поле, в которое записывается высота изображения, полученная из заголовка.
- `bmp->size`: это поле, в которое записывается размер файла, полученный из заголовка.

Таким образом, функция `getBMPHeaderData` позволяет получить данные заголовка BMP-файла и сохранить их в структуре `BMPHeader`. Эти данные могут быть использованы для дальнейшей обработки изображения, содержащегося в файле.

В заголовке BMP-файла ширина изображения (в пикселях) представлена в формате little-endian, где каждый байт представляет один байт информации. Формула `bmp->width = bmp->header[21] * 16777216 + bmp->header[20] * 65536 + bmp->header[19] * 256 + bmp->header[18];` используется для объединения четырех байтов (от 18-го до 21-го) в одно 32-битное целое число, чтобы получить ширину изображения.

Значение `bmp->header[18]` представляет самый младший байт (младший порядок байт), а `bmp->header[21]` представляет самый старший байт (старший порядок байт). Каждый байт умножается на соответствующую степень 256 и затем складывается, чтобы получить итоговое значение ширины.

Аналогичным образом, для высоты изображения используется формула `bmp->height = bmp->header[25] * 16777216 + bmp->header[24] * 65536 + bmp->header[23] * 256 + bmp->header[22];`, где значения байтов (от 22-го до 25-го) объединяются для получения высоты изображения.

Это делается потому, что в файле BMP числа хранятся в формате little-endian, где младший байт идет первым, а старший байт идет последним. При объединении байтов в число, необходимо учесть этот порядок и выполнить соответствующие преобразования.

## initImage

```c
int main(int argc, char *argv[]) {
    BMPHeader bmpHeader;
    GameConfig config = {1, 1, NULL};
    FILE *inputFile = NULL;

    parseCommandLineArgs(argc, argv, &config, &inputFile);

    getBMPHeaderData(inputFile, &bmpHeader);
    int **gameMap = initImage(bmpHeader, inputFile);
```

- `*` vs `**`
    - `*` перед названием означает указатель на переменную определенного типа данных. Он используется для хранения адреса памяти, где располагается значение переменной.
    - `**` перед названием означает указатель на указатель на переменную определенного типа данных. Он используется для хранения адреса памяти, где располагается указатель на переменную.
    
    Использование `*` и `**` зависит от контекста и требований программы. `*` используется, когда нужно работать с указателем на одну переменную, в то время как `**` используется, когда нужно работать с указателем на указатель на переменную.
    
    Например, в функции `initImage` из представленного кода, `int **gameMap` является указателем на указатель на целое число. Это позволяет выделить память для двумерного массива и сохранить адрес этой памяти в `gameMap`.
    
    Таким образом, использование `*` и `**` позволяет более гибко работать с указателями и динамической памятью в программировании на языке C.
    

```c
int **initImage(BMPHeader bmp, FILE *file) {
    int **image = (int **) malloc(bmp.height * sizeof(int *));
    for (int i = 0; i < bmp.height; ++i)
        image[i] = (int *) malloc(bmp.width * sizeof(int));

    unsigned char pixelData[bmp.size - 54];
    fread(pixelData, 1, bmp.size, file);

    int k = 0;
    for (int i = bmp.height - 1; i >= 0; --i) {
        k += (bmp.width % 4);
        for (int j = 0; j < bmp.width; ++j) {
            image[i][j] = (pixelData[k] == 255) ? 0 : 1;
            k += 3;
        }
    }

    return image;
}
```

Функция `initImage` используется для инициализации двумерного массива, который представляет изображение, считанное из файла BMP.

Она принимает следующие параметры:

- `bmp`: структура `BMPHeader`, содержащая данные заголовка BMP-файла.
- `file`: указатель на файл, из которого нужно считать данные пикселей изображения.

Внутри функции происходит выделение памяти для двумерного массива `image` с помощью функции `malloc`. Количество строк в массиве равно высоте изображения `bmp.height`, а количество столбцов равно ширине изображения `bmp.width`. Затем с помощью циклов происходит считывание данных пикселей изображения из файла и сохранение их в массиве `image`.

- Сначала создается временный массив `pixelData` для хранения считанных данных пикселей.
- Затем с помощью функции `fread` происходит чтение `bmp.size - 54` байтов из файла в массив `pixelData`. Обратите внимание, что 54 байта (заголовок BMP-файла) уже были прочитаны ранее при вызове функции `getBMPHeaderData`.
- Далее с помощью двух вложенных циклов происходит заполнение массива `image` данными пикселей из `pixelData`. Процесс заполнения происходит снизу вверх, так как в BMP-файле пиксели хранятся в обратном порядке по вертикали.
- Внутренний цикл проходит по каждому пикселю в строке изображения и сохраняет значение 0 или 1 в зависимости от цвета пикселя в массиве `image`. Если значение `pixelData[k]` равно 255 (белый цвет), то значение пикселя в `image` устанавливается равным 0, иначе (если `pixelData[k]` не равно 255) - равным 1.
- Переменная `k` используется для отслеживания текущей позиции в массиве `pixelData`.

Наконец, функция возвращает указатель на двумерный массив `image`, содержащий данные пикселей изображения.

Функция `initImage` является важной частью процесса обработки изображений в формате BMP и позволяет разместить данные пикселей в удобном для дальнейшей обработки формате.

## Итерационный цикл игры

```c
int main(int argc, char *argv[]) {
    BMPHeader bmpHeader;
    GameConfig config = {1, 1, NULL};
    FILE *inputFile = NULL;

    parseCommandLineArgs(argc, argv, &config, &inputFile);

    getBMPHeaderData(inputFile, &bmpHeader);
    int **gameMap = initImage(bmpHeader, inputFile);

    for (int iteration = 0; iteration <= config.maxIter; ++iteration) {
        saveNewSate(iteration, gameMap, bmpHeader, &config);
        runIteration(gameMap, bmpHeader.height, bmpHeader.width);
    }
```

### saveNewSate

```c
void saveNewSate(int iteration, int **image, BMPHeader bmp, GameConfig *config) {
    if (iteration % config->dumpFreq == 0) {
        char filename[20];
        char fullPath[100];
        sprintf(filename, "%d.bmp", iteration);
        strcpy(fullPath, config->output);
        strcat(fullPath, "\\");
        strcat(fullPath, filename);

        FILE *outputFile = fopen(fullPath, "wb");
        fwrite(bmp.header, 1, 54, outputFile);

        unsigned char pixelData[bmp.size - 54];
        for (int i = bmp.height - 1, m = 0; i >= 0; --i) {
            for (int j = 0; j < bmp.width; ++j)
                for (int k = 0; k < 3; ++k)
                    pixelData[m++] = (image[i][j] == 1) ? 0 : 255;
            while (m % 4 != 0)
                pixelData[m++] = 0;
        }

        fwrite(pixelData, 1, bmp.size, outputFile);
        fclose(outputFile);
    }
}
```

Функция `saveNewSate` используется для сохранения состояния игры в формате BMP. Она принимает следующие параметры:

- `iteration`: номер текущей итерации игры.
- `image`: двумерный массив, представляющий состояние игры.
- `bmp`: структура `BMPHeader`, содержащая данные заголовка BMP-файла.
- `config`: указатель на структуру `GameConfig`, содержащую конфигурационные данные игры.

Внутри функции происходит создание нового файла BMP для сохранения состояния игры. Для этого используется функция `fopen` с режимом записи (`"wb"`). Затем в файл записываются данные заголовка BMP-файла с помощью функции `fwrite`. Далее происходит формирование данных пикселей изображения и их запись в файл.

- Создается временный массив `pixelData` для хранения данных пикселей.
- С помощью вложенных циклов происходит заполнение массива `pixelData` значениями цвета пикселей в зависимости от состояния игры. Если значение `image[i][j]` равно 1 (живая клетка), то соответствующий пиксель в массиве `pixelData` устанавливается в черный цвет (0), иначе - в белый цвет (255).
- После заполнения массива `pixelData` происходит его запись в файл с помощью функции `fwrite`.
- Наконец, файл закрывается с помощью функции `fclose`.

Таким образом, функция `saveNewSate` позволяет сохранять текущее состояние игры в формате BMP на каждой итерации, если номер итерации кратен заданной частоте сохранения (`config->dumpFreq`).

Функция `saveNewSate` является важной частью процесса сохранения состояния игры и позволяет визуализировать прогресс игры в виде последовательности изображений BMP.

### runIteration

```c
void runIteration(int **map, int height, int width) {
    int liveCells, noChangeCells = 0;
    int tempMap[height][width];
    int x, y;

    for (x = 0; x < width; ++x) {
        for (y = 0; y < height; ++y) {
            tempMap[y][x] = map[y][x];
        }
    }

    for (x = 1; x < width - 1; ++x) {
        for (y = 1; y < height - 1; ++y) {
            liveCells = map[y - 1][x - 1] + map[y - 1][x] + map[y - 1][x + 1] + map[y][x - 1] + map[y][x + 1] +
                        map[y + 1][x - 1] + map[y + 1][x] + map[y + 1][x + 1];

            if (map[y][x] == 1 && (liveCells < 2 || liveCells > 3))
                tempMap[y][x] = 0;
            else if (map[y][x] != 1 && liveCells == 3)
                tempMap[y][x] = 1;
        }
    }

    for (x = 0; x < width; ++x) {
        for (y = 0; y < height; ++y) {
            if (map[y][x] == tempMap[y][x])
                ++noChangeCells;
            map[y][x] = tempMap[y][x];
        }
    }

    if (noChangeCells == height * width)
        exit(-4);
}
```

Функция `runIteration` используется для выполнения одной итерации игры "Жизнь". Она принимает следующие параметры:

- `map`: двумерный массив, представляющий текущее состояние игры.
- `height`: высота игрового поля.
- `width`: ширина игрового поля.

Внутри функции происходит выполнение правил игры "Жизнь" для каждой клетки на игровом поле.

- Создается временный двумерный массив `tempMap`, в котором будет сохранено новое состояние клеток после текущей итерации.
- С помощью вложенных циклов происходит копирование текущего состояния игры из массива `map` в массив `tempMap`.
- Затем с помощью еще двух вложенных циклов происходит проверка и применение правил игры "Жизнь" для каждой клетки.
- Для каждой клетки на игровом поле вычисляется количество живых соседей (`liveCells`), подсчитывая значение восьми соседних клеток.
- Если клетка является живой (`map[y]== 1`) и количество живых соседей меньше 2 или больше 3, то она становится мертвой (`tempMap[y]= 0`).
- Если клетка является мертвой (`map[y]!= 1`) и количество живых соседей равно 3, то она становится живой (`tempMap[y]= 1`).
- После обработки всех клеток, новое состояние игры сохраняется обратно в массив `map`.
- Если на текущей итерации ни одна клетка не изменила свое состояние, то функция выходит из программы с кодом `4`.

Таким образом, функция `runIteration` выполняет одну итерацию игры "Жизнь", обновляя состояние клеток на игровом поле в соответствии с правилами игры.

Функция `runIteration` является ключевой частью алгоритма игры "Жизнь" и позволяет симулировать эволюцию клеток на игровом поле.

## freeImageMemory

```c
int main(int argc, char *argv[]) {
    BMPHeader bmpHeader;
    GameConfig config = {1, 1, NULL};
    FILE *inputFile = NULL;

    parseCommandLineArgs(argc, argv, &config, &inputFile);

    getBMPHeaderData(inputFile, &bmpHeader);
    int **gameMap = initImage(bmpHeader, inputFile);

    for (int iteration = 0; iteration <= config.maxIter; ++iteration) {
        saveNewSate(iteration, gameMap, bmpHeader, &config);
        runIteration(gameMap, bmpHeader.height, bmpHeader.width);
    }

    freeImageMemory(gameMap, bmpHeader.height);
    fclose(inputFile);
```

```c
void freeImageMemory(int **image, int height) {
    for (int i = 0; i < height; ++i)
        free(image[i]);
    free(image);
}
```

Функция `freeImageMemory` используется для освобождения памяти, выделенной под двумерный массив `image`, который представляет изображение игры.

Она принимает следующие параметры:

- `image`: двумерный массив, который нужно освободить.
- `height`: высота массива.

Внутри функции происходит освобождение памяти, выделенной под каждую строку массива `image`, с помощью функции `free`. Затем освобождается память, выделенная под сам массив `image` с помощью функции `free`.

Таким образом, функция `freeImageMemory` позволяет освободить память, которая была выделена под двумерный массив `image`, после того, как он больше не нужен.

Функция `freeImageMemory` является важной частью процесса управления памятью и предотвращает утечки памяти в программе.

## Итоговый main

```c
int main(int argc, char *argv[]) {
    BMPHeader bmpHeader;
    GameConfig config = {1, 1, NULL};
    FILE *inputFile = NULL;

    parseCommandLineArgs(argc, argv, &config, &inputFile);

    getBMPHeaderData(inputFile, &bmpHeader);
    int **gameMap = initImage(bmpHeader, inputFile);

    for (int iteration = 0; iteration <= config.maxIter; ++iteration) {
        saveNewSate(iteration, gameMap, bmpHeader, &config);
        runIteration(gameMap, bmpHeader.height, bmpHeader.width);
    }

    freeImageMemory(gameMap, bmpHeader.height);
    fclose(inputFile);

    return 0;
}
```

# Полный код

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <direct.h>

typedef struct {
    unsigned char header[54];
    int width;
    int height;
    int size;
} BMPHeader;

typedef struct {
    int maxIter;
    int dumpFreq;
    char *output;
} GameConfig;

void parseCommandLineArgs(int argc, char *argv[], GameConfig *config, FILE **inputFile) {
    for (int i = 1; i < argc; ++i) {
        if (!strcmp("--input", argv[i]) && i + 1 < argc) {
            *inputFile = fopen(argv[i + 1], "rb");
            if (!*inputFile)
                perror("Error opening input file");
        } else if (!strcmp("--output", argv[i]) && i + 1 < argc) {
            config->output = argv[i + 1];
            mkdir(config->output);
        } else if (!strcmp("--max_iter", argv[i]) && i + 1 < argc) {
            config->maxIter = strtol(argv[i + 1], NULL, 10);
        } else if (!strcmp("--dump_freq", argv[i]) && i + 1 < argc) {
            config->dumpFreq = strtol(argv[i + 1], NULL, 10);
        }
    }
}

void getBMPHeaderData(FILE *file, BMPHeader *bmp) {
    fread(bmp->header, 1, 54, file);
    bmp->width = bmp->header[21] * 16777216 + bmp->header[20] * 65536 + bmp->header[19] * 256 + bmp->header[18];
    bmp->height = bmp->header[25] * 16777216 + bmp->header[24] * 65536 + bmp->header[23] * 256 + bmp->header[22];
    bmp->size = bmp->header[5] * 16777216 + bmp->header[4] * 65536 + bmp->header[3] * 256 + bmp->header[2];
}

int **initImage(BMPHeader bmp, FILE *file) {
    int **image = (int **) malloc(bmp.height * sizeof(int *));
    for (int i = 0; i < bmp.height; ++i)
        image[i] = (int *) malloc(bmp.width * sizeof(int));

    unsigned char pixelData[bmp.size - 54];
    fread(pixelData, 1, bmp.size, file);

    int k = 0;
    for (int i = bmp.height - 1; i >= 0; --i) {
        k += (bmp.width % 4);
        for (int j = 0; j < bmp.width; ++j) {
            image[i][j] = (pixelData[k] == 255) ? 0 : 1;
            k += 3;
        }
    }

    return image;
}

void saveNewSate(int iteration, int **image, BMPHeader bmp, GameConfig *config) {
    if (iteration % config->dumpFreq == 0) {
        char filename[20];
        char fullPath[100];
        sprintf(filename, "%d.bmp", iteration);
        strcpy(fullPath, config->output);
        strcat(fullPath, "\\");
        strcat(fullPath, filename);

        FILE *outputFile = fopen(fullPath, "wb");
        fwrite(bmp.header, 1, 54, outputFile);

        unsigned char pixelData[bmp.size - 54];
        for (int i = bmp.height - 1, m = 0; i >= 0; --i) {
            for (int j = 0; j < bmp.width; ++j)
                for (int k = 0; k < 3; ++k)
                    pixelData[m++] = (image[i][j] == 1) ? 0 : 255;
            while (m % 4 != 0)
                pixelData[m++] = 0;
        }

        fwrite(pixelData, 1, bmp.size, outputFile);
        fclose(outputFile);
    }
}

void runIteration(int **map, int height, int width) {
    int liveCells, noChangeCells = 0;
    int tempMap[height][width];
    int x, y;

    for (x = 0; x < width; ++x) {
        for (y = 0; y < height; ++y) {
            tempMap[y][x] = map[y][x];
        }
    }

    for (x = 1; x < width - 1; ++x) {
        for (y = 1; y < height - 1; ++y) {
            liveCells = map[y - 1][x - 1] + map[y - 1][x] + map[y - 1][x + 1] + map[y][x - 1] + map[y][x + 1] +
                        map[y + 1][x - 1] + map[y + 1][x] + map[y + 1][x + 1];

            if (map[y][x] == 1 && (liveCells < 2 || liveCells > 3))
                tempMap[y][x] = 0;
            else if (map[y][x] != 1 && liveCells == 3)
                tempMap[y][x] = 1;
        }
    }

    for (x = 0; x < width; ++x) {
        for (y = 0; y < height; ++y) {
            if (map[y][x] == tempMap[y][x])
                ++noChangeCells;
            map[y][x] = tempMap[y][x];
        }
    }

    if (noChangeCells == height * width)
        exit(-4);
}

void freeImageMemory(int **image, int height) {
    for (int i = 0; i < height; ++i)
        free(image[i]);
    free(image);
}

int main(int argc, char *argv[]) {
    BMPHeader bmpHeader;
    GameConfig config = {1, 1, NULL};
    FILE *inputFile = NULL;

    parseCommandLineArgs(argc, argv, &config, &inputFile);

    getBMPHeaderData(inputFile, &bmpHeader);
    int **gameMap = initImage(bmpHeader, inputFile);

    for (int iteration = 0; iteration <= config.maxIter; ++iteration) {
        saveNewSate(iteration, gameMap, bmpHeader, &config);
        runIteration(gameMap, bmpHeader.height, bmpHeader.width);
    }

    freeImageMemory(gameMap, bmpHeader.height);
    fclose(inputFile);

    return 0;
}
```

# План по улучшению

- [ ]  rgb32 (для особых любителей принимать лабы)
- [ ]  `--max_iter N`
Максимальное число поколений которое может эмулировать
программа. Необязательный параметр, по-умолчанию бесконечность
(актуальная имплементация — по-умолчанию 1)
